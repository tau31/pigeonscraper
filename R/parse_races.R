# Parse html source with race tables ------------------

#' Parse html source with race tables
#'
#' @param css_query_tbl table with year and organization css queries, generated
#' by the function \code{\link{extract_orgs}}.
#' @param remDr Object class remote driver previosly connected using
#' \code{\link{connect_remDr}}.
#'
#' @return xml_nodeset of parsed html options to be used to build queries.
#'
#' @import RSelenium
#' @import rlang

extract_race_html_options <-
  function(css_query_tbl, remDr) {
    year_element <- remDr$findElement(
      using = "css selector",
      value = css_query_tbl$css_query_year)
    # Click year element
    year_element$clickElement()

    temp_orgs <- xml2::read_html(year_element$getPageSource()[[1]]) %>%
      rvest::html_nodes("#organization-selection") %>%
      rvest::html_children()

    #### Check if page is loaded ####

    # Test if the elements of the page have finished loading
    # Create testing object
    test_loading <- stringr::str_detect(rvest::html_text(temp_orgs),"Loading")

    # While loading is still the element being acessed, wait 3 seconds
    # if it is still the same, wait more time.
    # repeat until the while evaluation is FALSE.
    while (TRUE %in% test_loading) {
      # Wait
      Sys.sleep(1)
      # Parse the html again
      temp_orgs <- xml2::read_html(year_element$getPageSource()[[1]]) %>%
        rvest::html_nodes("#organization-selection") %>%
        rvest::html_children()
      # generate new testing string
      test_loading <- stringr::str_detect(
        rvest::html_text(temp_orgs), "Loading")
    }

    #### Organizations query ####

    org_element <- remDr$findElement(
      using = "css selector",
      value = css_query_tbl$css_query_org)

    org_element$clickElement()

    temp_races <- xml2::read_html(org_element$getPageSource()[[1]]) %>%
      rvest::html_nodes("#race-selection") %>%
      rvest::html_children()

    #### Test if page is loaded ####

    test_loading <- stringr::str_detect(
      rvest::html_text(temp_races),"Loading")

    # While loading is still the element being acessed, wait 3 seconds
    # if it is still the same, wait more time.
    # repeat until the while evaluation is FALSE.
    while (TRUE %in% test_loading) {
      # Wait
      Sys.sleep(1)
      # Parse the html again
      temp_races <- xml2::read_html(org_element$getPageSource()[[1]]) %>%
        rvest::html_nodes("#race-selection") %>%
        rvest::html_children()
      # generate new testing string
      test_loading <- stringr::str_detect(
        rvest::html_text(temp_races),"Loading")
    }
    return(temp_races)
  }

# Parse source html with race tables -----

#' Parsing html tables for each individual race in a xml_nodeset.
#'
#' @param race_xml_nodeset xml_nodeset generated by
#' \code{\link{extract_race_html_options}}.
#' @param remDr Object class remote driver previosly connected using
#'
#' @return XML document with race tables.
#'
#' @import RSelenium
#' @import rlang

race_table_parse <-
  function(race_xml_nodeset, remDr) {
    . <- NULL

    temp_race <- purrr::map(
      1:length(race_xml_nodeset),
      function(race) {
        css_query_race <- stringr::str_c(
          "#race-selection > option:nth-child(",
          race,
          ")")
        race_element <- remDr$findElement(using = "css selector",
                                          value = css_query_race)
        race_element$clickElement()
        Sys.sleep(1)

        temp_race <- xml2::read_html(race_element$getPageSource()[[1]])

        #### Check if table is loaded ####

        # Check if table is loaded
        test_loaded_table <-
          temp_race %>%
          rvest::html_node("table") %>%
          rvest::html_table(fill = TRUE) %>%
          .[[1]] %>%
          tibble::as_tibble()

        # Some tables will have no data.
        # So, I created a timeout for this test.
        # After 5 seconds of wating there is no info on the table
        # we assume that is the case and move on.
        trial <- 1

        while(nrow(test_loaded_table) == 0 & trial < 5) {
          Sys.sleep(1)
          temp_race <- xml2::read_html(race_element$getPageSource()[[1]])
          test_loaded_table <-
            temp_race %>%
            rvest::html_node("table") %>%
            rvest::html_table(fill = TRUE) %>%
            .[[1]] %>%
            tibble::as_tibble()
          trial = trial + 1;
        } # while loop

        return(temp_race)
      } # map function
    ) # map
  }
